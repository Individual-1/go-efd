// Package efdtools implements helper functions for interacting with the efd search
package efdtools

import (
	"crypto/tls"
	"log"
	"math/rand"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"strconv"
	"strings"

	"golang.org/x/net/html"
	"golang.org/x/net/publicsuffix"
)

var jar http.CookieJar
var client *http.Client
var homeURL url.URL
var searchURL url.URL
var searchDataURL url.URL

const userAgent string = "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0"

func init() {
	jar, _ = cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})

	var proxyURL, _ = url.Parse("http://172.29.192.1:8080")
	var tr = &http.Transport{
		Proxy:           http.ProxyURL(proxyURL),
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client = &http.Client{Jar: jar, Transport: tr}

	const baseURLString string = "https://efdsearch.senate.gov"
	const homeURLString string = "/search/home/"
	const searchURLString string = "/search/"
	const searchDataURLString string = "/search/report/data/"

	var baseURL, _ = url.Parse(baseURLString)
	var homeURLComponent, _ = url.Parse(homeURLString)
	var searchURLComponent, _ = url.Parse(searchURLString)
	var searchDataURLComponent, _ = url.Parse(searchDataURLString)

	homeURL = *baseURL.ResolveReference(homeURLComponent)
	searchURL = *baseURL.ResolveReference(searchURLComponent)
	searchDataURL = *baseURL.ResolveReference(searchDataURLComponent)
}

var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func randSeq(n int) string {
	b := make([]rune, n)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}

func searchReportData() string {
	data := url.Values{}

	// Target first name
	data.Set("first_name", "")
	// Target last name
	data.Set("last_name", "")
	// Target filer type (Senator is 1)
	data.Set("filer_types", "[1]")
	// Target state represented
	data.Set("senator_state", "")
	// Report type (PTR is 11)
	data.Set("report_types", "[11]")
	// Beginning of date range to search (Format is MM/DD/YYYY HH:MM:SS)
	data.Set("submitted_start_date", "")
	// End of date range to search (Format is MM/DD/YYYY HH:MM:SS)
	data.Set("submitted_end_date", "")
	// CSRF token
	data.Set("csrftoken", csrftoken)

	req, err := http.NewRequest("POST", searchURL.String(), strings.NewReader(data.Encode()))
	if err != nil {
		return false
	}

	req.Header.Add("Referer", searchURL.String())
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Add("Content-Length", strconv.Itoa(len(data.Encode())))
	req.Header.Add("User-Agent", userAgent)

	resp, err := client.Do(req)
	if err != nil {
		return false
	}

	resp.Body.Close()

	return true
}

// clearClient initializes an empty cookiejar and http client. This should be run to clear all client context.
func clearClient() {
	/*
		Should be safe to run this multiple times
		There is no cookiejar.Clear type method so we need to create a new one to empty it out
	*/
	jar, _ = cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})
	client = &http.Client{Jar: jar}
}

// AcceptDisclaimer goes through the process of accepting the initial disclaimer
// and setting up session data for search
func AcceptDisclaimer() bool {
	csrftoken := getCSRFToken(homeURL)
	if csrftoken == "" {
		return false
	}

	data := url.Values{}
	data.Set("prohibition_agreement", "1")
	data.Set("csrfmiddlewaretoken", csrftoken)

	req, err := http.NewRequest("POST", homeURL.String(), strings.NewReader(data.Encode()))
	if err != nil {
		return false
	}

	req.Header.Add("Referer", homeURL.String())
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Add("Content-Length", strconv.Itoa(len(data.Encode())))
	req.Header.Add("User-Agent", userAgent)

	resp, err := client.Do(req)
	if err != nil {
		return false
	}

	resp.Body.Close()

	return true
}

// SearchPTR searches for all Periodic Transaction Reports for a given date range
func SearchPTR() bool {
	csrftoken := getCSRFToken(searchURL)
	if csrftoken == "" {
		return false
	}

	data := url.Values{}

	// Target first name
	data.Set("first_name", "")
	// Target last name
	data.Set("last_name", "")
	// Target filer type (Senator is 1)
	data.Set("filer_type", "1")
	// Target state represented
	data.Set("senator_state", "")
	// Report type (PTR is 11)
	data.Set("report_type", "11")
	// Beginning of date range to search (Format is MM/DD/YYYY)
	data.Set("submitted_start_date", "")
	// End of date range to search (Format is MM/DD/YYYY)
	data.Set("submitted_end_date", "")
	// CSRF token
	data.Set("csrfmiddlewaretoken", csrftoken)

	req, err := http.NewRequest("POST", searchURL.String(), strings.NewReader(data.Encode()))
	if err != nil {
		return false
	}

	req.Header.Add("Referer", searchURL.String())
	req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Add("Content-Length", strconv.Itoa(len(data.Encode())))
	req.Header.Add("User-Agent", userAgent)

	resp, err := client.Do(req)
	if err != nil {
		return false
	}

	resp.Body.Close()

	return true
}

func getCSRFToken(url url.URL) string {
	req, err := http.NewRequest("GET", url.String(), nil)
	if err != nil {
		log.Fatal(err)
	}

	req.Header.Add("User-Agent", userAgent)

	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}

	defer resp.Body.Close()
	z := html.NewTokenizer(resp.Body)

	var csrftoken string = ""

	// Iterate over tokens until we find the csrfmiddlewaretoken
	for {
		tt := z.Next()
		if tt == html.ErrorToken {
			return csrftoken
		}

		switch tt {
		case html.StartTagToken:
			t := z.Token()

			if t.Data == "input" {
				var found bool = false
				for _, a := range t.Attr {
					if a.Key == "name" && a.Val == "csrfmiddlewaretoken" {
						found = true
						break
					}
				}

				if found {
					for _, a := range t.Attr {
						if a.Key == "value" {
							csrftoken = a.Val
							break
						}
					}
				}
			}
		}

		if csrftoken != "" {
			break
		}
	}

	return csrftoken
}
